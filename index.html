<!DOCTYPE html>
<html lang="en">
<head>
<title>JSON-LD-star</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script src="common/common.js" class="remove" defer></script>
<script class='remove'>
  var respecConfig = {
    localBiblio: {
      "RDFStar": {
        "title": "RDF-star and SPARQL-star",
        "authors": [
          "Olaf Hartig",
          "Pierre-Antoine Champin"
        ],
        "publisher": "W3C",
        "status": "W3C CG Draft",
        "href": "https://w3c.github.io/rdf-star/cg-spec/2021-02-18.html",
        "editors": ["Olaf Hartig", "Pierre-Antoine Champin"],
        "date": "2021-02-18"
      },
      "JSON-LD-star-tests": {
        "title": "JSON-LD-star Test Suite",
        "author": "Gregg Kellogg",
        "publisher": "W3C",
        "status": "unofficial",
        "href": "https://json-ld.github.io/json-ld-star/tests/"
      }
    },
    specStatus: "ED",
    copyrightStart:    "2020",
    shortName:  "json-ld-star",
    edDraftURI: "https://json-ld.github.io/json-ld-star/",
    testSuiteURI: "https://json-ld.github.io/json-ld-star/tests/",
    implementationReportURI:"https://json-ld.github.io/json-ld-star/reports/",
    github:     "https://github.com/json-ld/json-ld-star/",
    doJsonLd:   true,
    editors: [{
      name: "Gregg Kellogg",
      url: "http://greggkellogg.net/",
      w3cid: "44770"
    }, {
      name:       "Pierre-Antoine Champin",
      url:        "http://champin.net/",
      company:    "ERCIM",
      companyURL: "https://www.ercim.eu/",
      w3cid:      42931,
      orcid:      "0000-0001-7046-4474",
    }],
    //previousMaturity: "FPWD",
    //previousPublishDate: "1977-03-15",

    // Cross-reference definitions
    xref: ["json-ld11", "json-ld11-api", "json-ld11-framing"],

    group: "cg/json-ld",
    wgPublicList: "public-linked-json",
    maxTocLevel:        4,
    noRecTrack:         "true"
  };
</script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Add example button selection logic
    for (const button of document.querySelectorAll(".ds-selector-tabs .selectors button")) {
      button.onclick = () => {
        const ex = button.closest(".ds-selector-tabs");
        ex.querySelector("button.selected").classList.remove("selected");
        ex.querySelector(".selected").classList.remove("selected");
        button.classList.add('selected');
        ex.querySelector("." + button.dataset.selects).classList.add("selected");
      }
    }

    // Toggle show/hide changes
    for (const elem of document.querySelectorAll(".show-changes")) {
      elem.onclick = () => {
        if (elem.classList.contains("selected")) {
          // Remove highlight class from elements having "changed" class
          elem.classList.remove("selected");
          for (const changed of document.querySelectorAll(".changed")) {
            changed.classList.remove("highlight");
          }
        } else {
          // Add highlight class to elements having "changed" class
          elem.classList.add("selected");
          for (const changed of document.querySelectorAll(".changed")) {
            changed.classList.add("highlight");
          }
        }
      }
    }
  });
</script>
<style>
  .hidden { display: none;}
  .hl-bold { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td { padding: 5px; border-width: 1px; border-spacing: 0px; border-style: solid; border-collapse: collapse; }
  table.example {width: 100%;}
  .example > pre.context:before {
    content: "Context";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.frame:before {
    content: "Frame";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.input:before {
    content: "Input";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.result:before {
    content: "Result";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.flattened:before {
    content: "Flattened";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.expanded:before {
    content: "Expanded";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.turtle:before {
    content: "Turtle";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  aside.example {
    overflow-y: hidden;
  }
  /* example tab selection */
  .ds-selector-tabs {
    padding-bottom: 2em;
  }
  .ds-selector-tabs .selectors {
    padding: 0;
    border-bottom: 1px solid #ccc;
    height: 28px;
  }
  .ds-selector-tabs .selectors button {
    display: inline-block;
    min-width: 54px;
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    height: 27px;
    padding: 0 8px;
    line-height: 27px;
    transition: all,0.218s;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    color: #666;
    border: 1px solid transparent;
  }
  .ds-selector-tabs .selectors button:first-child {
    margin-left: 2px;
  }
  .ds-selector-tabs .selectors button.selected {
    color: #202020 !important;
    border: 1px solid #ccc;
    border-bottom: 1px solid #fff !important;
  }
  .ds-selector-tabs .selectors button:hover {
    background-color: transparent;
    color: #202020;
    cursor: pointer;
  }
  .ds-selector-tabs pre:not(.preserve), .ds-selector-tabs table:not(.preserve) {
    display: none;
  }
  .ds-selector-tabs pre.selected, .ds-selector-tabs table.selected {
    display: block;
  }
  a.playground {
    display: inline-block;
    width: 150px;
    border: 1px solid transparent;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    background-color: rgb(192, 192, 192);
    text-decoration: none;
    font-size: 13px;
    margin-bottom: 10px;
  }
  a[href].playground {
    padding: 4px 0 3px 8px;
    border-bottom: none;
    text-decoration: none;
    color: #666;
  }
  .algorithm ol {
    counter-reset: numsection;
    list-style-type: none;
  }
  .algorithm ol>li {
    margin: 0.5em 0;
  }
  .algorithm ol>li:before {
    font-weight: bold;
    counter-increment: numsection;
    content: counters(numsection, ".") ") ";
  }
</style>
</head>
  <body>
    <section id='abstract'>
      <p>
        This NOTE describes an extension to [[JSON-LD11]], [[JSON-LD11-API]],
        and [[JSON-LD11-FRAMING]] to allow arcs in a <a>Linked Data Graph</a> to
        be annotated using the [[RDFStar]] model.
      </p>
    </section>

    <section id='sotd'>
      <p>
        This is an unofficial proposal.
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>[[[RDFStar]]] [[RDFStar]] addresses the problem of annotating arcs in a <a>Linked Data Graph</a>
        by extending the <a data-cite="RDF11-CONCEPTS#data-model">RDF data model</a> [[RDF11-CONCEPTS]] to allow for triples
        to be used as the <a>subject</a>
        or <a>object</a> of another <a data-cite="RDF11-CONCEPTS#dfn-rdf-triple">RDF triple</a>.
        This note describes an update to the <a data-cite="JSON-LD11#data-model">JSON-LD data model</a>
        to allow limited form of a <a data-cite="JSON-LD11#dfn-node-object">node object</a>
        to use another <a data-cite="JSON-LD11#dfn-node-object">node object</a> as its node identifier.</p>

      <p>The two popular graph-based data models have been RDF [[RDF11-CONCEPTS]] and
        <dfn href="https://en.wikipedia.org/wiki/Graph_database#Labeled-property_graph" data-lt="Property Graph">Labeled-property Graphs</dfn>,
        which are roughly similar, with the RDF model being more formal in identifying nodes,
        datatypes and relationships, while Property Graphs
        use a less formal relationship model somewhat similar to JSON. In both models,
        nodes are related via edges (AKA arcs), but in Property Graphs,
        those edges may themselves be annotated with properties.
        This is useful in providing additional metadata and semantics to relationships of the nodes.</p>

      <p>Historically, in RDF, this can be simulated through <a href="https://www.w3.org/wiki/RdfReification">Reification</a>,
        where a <a>triple</a> is represented by another resource with properties for the <a>subject</a>, <a>predicate</a>, and <a>object</a>,
        which allows additional properties to be asserted on that reification node.</p>

      <pre class="example turtle"
           data-transform="updateExample"
           data-content-type="text/turtle"
           title="An RDF Triple and its Reification">
      <!--
        @base <http://example.org/> .
        @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
        @prefix : <#> .

        :bob :age 42 .

        # Reification of previous triple
        [
          a rdf:Statement;
          rdf:subject :bob;
          rdf:predicate :age;
          rdf:object 42
        ] .
      -->
      </pre>

      <p>In [[RDFStar]], a <a>triple</a> may act as the <a>subject</a> or <a>object</a> in another <a>triple</a>,
        for example, we can modify how certain we are about a relationship as follows:</p>

      <pre class="example turtle"
           data-transform="updateExample"
           data-content-type="text/turtle"
           data-options="rdfstar=true"
           title="Annotation on an RDF triple">
      <!--
        @base <http://example.org/> .
        @prefix : <#> .

        :bob :age 42.
        << :bob :age 42 >> :source <http://example.org/~bob/>.
      -->
      </pre>

      <p>This NOTE explores an extension of JSON-LD which can allow
        the value of an `@id` property to be an <a>embedded node</a>,
        and the description of an <a>annotation object</a> which serves as
        a short-hand when the annotated value also is described
        directly in the graph.</p>
    </section>

  <div class="informative hidden">
    <!-- Terms included for referencability, but not displayed -->
    <div data-include="common/terms.html"></div>
    <div data-include="common/algorithm-terms.html"></div>
  </div>

  <section id="conformance">
    <p>A <a>JSON-LD-star document</a> complies with this specification if it follows
      the normative statements in <a href="#grammar-extensions"></a>.
      For convenience, normative
      statements for documents are often phrased as statements on the properties of the document.</p>

    <p>This specification makes use of the following namespace prefixes:</p>
    <table class="simple">
      <thead><tr>
        <th>Prefix</th>
        <th>IRI</th>
      </tr></thead>
      <tbody>
        <tr>
          <td>ex</td>
          <td>http://example.org/</td>
        </tr>
        <tr>
          <td>rdf</td>
          <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td>
        </tr>
        <tr>
          <td>xsd</td>
          <td>http://www.w3.org/2001/XMLSchema#</td>
        </tr>
      </tbody>
    </table>

    <p>These are used within this document as part of a <a>compact IRI</a>
      as a shorthand for the resulting <a>IRI</a>, such as <code>dcterms:title</code>
      used to represent <code>http://purl.org/dc/terms/title</code>.</p>
  </section>

  <section class="informative">
    <h2>JSON-LD-star-specific Terms</h2>

    <p>The Following terms are used within specific algorithms.</p>

    <dl data-sort>
      <dt><dfn data-cite="RDFStar#dfn-dataset">RDF-star dataset</dfn></dt><dd>
        An <a>RDF dataset</a> extended to allow the use of an
        <a>RDF-star graph</a> instead of a plain <a>RDF graph</a>.
      </dd>
      <dt><dfn data-cite="RDFStar#dfn-graph">RDF-star graph</dfn></dt><dd>
        A set of <a>RDF-star triples</a>.
      </dd>
      <dt><dfn data-cite="RDFStar#dfn-triple">RDF-star triple</dfn></dt><dd>
        An <a data-cite="RDF11-CONCEPTS#dfn-rdf-triple">RDF triple</a> extended to allow an <a>RDF-star triple</a> to be
        used in the <a>subject</a> or <a>object</a> position.
      </dd>
      <dt><dfn >Embedded Node</dfn></dt><dd>
        An <a>embedded node</a> is a <a>node object</a> describing exactly one <a>property</a>/value pair.
        The <a>node object</a> MAY be identified as with other node objects (including with an <a>embedded node</a>).
        The <a>property</a> MUST be either `@type` or an <a>IRI</a>.
        The property value MUST be either an <a>IRI</a>, <a>blank node</a>, <a>literal</a> or an <a>embedded node</a>.
        An <a>embedded node</a> MAY contain other <a>entries</a> that do not, themselves, create directed-arcs, such
        as `@context` or `@index`.
        An <a>embedded triples</a> is the representation of an <dfn data-cite="RDFStar#dfn-embedded-triple">embedded triple</dfn>.
      </dd>
      <dt><dfn>JSON-LD-star document</dfn></dt><dd>
        A <a>JSON-LD-star document</a> is a serialization of
        an <a>RDF dataset</a> as extended by [[RDFStar]].
      </dd>
      <dt><dfn>Annotation Object</dfn></dt><dd>
        An <a>annotation object</a> is a <a>node object</a> which is the value
        of `@annotation` (or an alias). It describes [[RDFStar]] annotations
        made on the <a>triple</a> between by its parent <a>node object</a> or <a>value object</a>, and the parent's closest ancestor <a>node object</a>.
      </dd>
    </dl>
  </section>

  <section id="basic-concepts" class="informative">
    <h2>Basic Concepts</h2>

    <p>This specification adds the concepts of an <a>embedded node</a>
      and <a>annotation object</a> to JSON-LD in order to add the
      ability to make statements about individual <a>triples</a> in an
      <a>RDF-star Graph</a>.</p>

    <p>An <a>embedded node</a> supports the ability to make one or more statements
      about a <a>triple</a>, represented by an <a>embedded node</a>, without that
      triple being necessarily considered to be part of the <a>Linked Data Graph</a>.</p>

    <p>The following example shows how the value of `@id` can be an
      of <a>embedded node</a>, which expresses a single <a>triple</a>:</p>

    <aside class="example ds-selector-tabs"
           title="Embedded node as subject">
      <div class="selectors">
        <button class="selected input" data-selects="compacted">Compacted (Input)</button>
        <button data-selects="expanded">Expanded</button>
        <button data-selects="flattened">Flattened</button>
        <button data-selects="turtle">Turtle-star</button>
      </div>
      <pre class="compacted input selected"
           data-transform="updateExample"
           data-options="rdfstar=true">
      <!--
        {
          "@context": {
            "@base": "http://example.org/",
            "@vocab": "http://example.org/"
          },
          "@id": {
            "@id": "bob",
            "age": 42
          },
          "certainty": 0.8
        }
      -->
      </pre>
      <pre class="expanded"
           data-transform="updateExample"
           data-options="rdfstar=true"
           data-result-for="Embedded node as subject-compacted">
      <!--
        [{
          "@id": {
            "@id": "http://example.org/bob",
            "http://example.org/age": [{"@value": 42}]
          },
          "http://example.org/certainty": [{"@value": 0.8}]
        }]
      -->
      </pre>
      <pre class="flattened"
           data-transform="updateExample"
           data-options="rdfstar=true"
           data-flatten
           data-result-for="Embedded node as subject-compacted">
      <!--
        [{
          "@id": {
            "@id": "http://example.org/bob",
            "http://example.org/age": [{"@value": 42}]
          },
          "http://example.org/certainty": [{"@value": 0.8}]
        }]
      -->
      </pre>
      <pre class="turtle"
           data-content-type="text/turtle"
           data-transform="updateExample"
           data-options="rdfstar=true,canonicalize=true"
           data-to-rdf
           data-result-for="Embedded node as subject-compacted">
      <!--
      @prefix : <http://example.org/> .

      << :bob :age 42 >> :certainty 0.8e0 .
      -->
      </pre>
    </aside>

    <p>An <a>annotation object</a> supports the ability to make one or more statements (annotations)
      about a <a>triple</a>, where the <a>triple</a> <em>is</em> considered to be part of the <a>Linked Data Graph</a>.</p>

    <aside class="example ds-selector-tabs"
           title="Annotating a node">
      <div class="selectors">
        <button class="selected input" data-selects="compacted">Compacted (Input)</button>
        <button data-selects="expanded">Expanded</button>
        <button data-selects="flattened">Flattened</button>
        <button data-selects="turtle">Turtle-star</button>
      </div>
      <pre class="compacted input selected"
           data-transform="updateExample"
           data-options="rdfstar=true">
      <!--
        {
          "@context": {
            "@base": "http://example.org/",
            "@vocab": "http://example.org/"
          },
          "@id": "bob",
          "age": {
            "@value": 42,
            "@annotation": {
              "certainty": 0.8
            }
          }
        }
      -->
      </pre>
      <pre class="expanded"
           data-transform="updateExample"
           data-options="rdfstar=true"
           data-result-for="Annotating a node-compacted">
      <!--
        [{
          "@id": "http://example.org/bob",
          "http://example.org/age": [{
            "@value": 42,
            "@annotation": [{
              "http://example.org/certainty": [{"@value": 0.8}]
            }]
          }]
        }]
      -->
      </pre>
      <pre class="flattened"
           data-transform="updateExample"
           data-options="rdfstar=true"
           data-flatten
           data-result-for="Annotating a node-compacted">
      <!--
        [{
          "@id": "http://example.org/bob",
          "http://example.org/age": [{"@value": 42}]
        }, {
          "@id": {
            "@id": "http://example.org/bob",
            "http://example.org/age": [{"@value": 42}]
          },
          "http://example.org/certainty": [{"@value": 0.8}]
        }]
      -->
      </pre>
      <pre class="turtle"
           data-content-type="text/turtle"
           data-transform="updateExample"
           data-options="rdfstar=true,canonicalize=true"
           data-to-rdf
           data-result-for="Annotating a node-compacted">
      <!--
      @prefix : <http://example.org/> .

      :bob :age 42 .
      << :bob :age 42 >> :certainty 0.8e0 .
      -->
      </pre>
    </aside>
  </section>

  <section id="advanced-concepts" class="informative">
    <h2>Advanced Concepts</h2>
    <p>JSON-LD allows many more sophisticated ways of describing data and
      both <a>embedded nodes</a> and <a>annotation objects</a> work along with these
      other features, to the extent that they are used in describing a single relationship.</p>

    <section id="reverse-properties" class="informative">
      <h3>Reverse Properties</h3>
      <p>JSON-LD allows the description of <a data-cite="JSON-LD11#reverse-proerties"></a>
        within <a>node objects</a>, either by defining a term using `@reverse`, or using
        `@reverse` directly within a <a>node object</a>.</p>

      <p>An <a>embedded node</a> MUST NOT, itself, use a reverse property.</p>

      <p>The relationships between nodes can be reversed even when those
        nodes use embedded objects:</p>

      <aside class="example ds-selector-tabs"
             title="Reversing relationship with embedded node">
        <div class="selectors">
          <button class="selected input" data-selects="compacted">Compacted (Input)</button>
          <button data-selects="expanded">Expanded</button>
          <button data-selects="flattened">Flattened</button>
          <button data-selects="turtle">Turtle-star</button>
        </div>
        <pre class="compacted input selected"
             data-transform="updateExample"
             data-options="rdfstar=true">
        <!--
          {
            "@context": {
              "@base": "http://example.org/",
              "@vocab": "http://example.org/",
              "knows": {"@type": "@id"},
              "claimedBy": {"@reverse": "http://example.org/claims", "@type": "@id"}
            },
            "@id": {
              "@id": "bob",
              "knows": "alice"
            },
            "claimedBy": "alice"
          }
        -->
        </pre>
        <pre class="expanded"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-result-for="Reversing relationship with embedded node-compacted">
        <!--
          [{
            "@id": {
              "@id": "http://example.org/bob",
              "http://example.org/knows": [{"@id": "http://example.org/alice"}]
            },
            "@reverse": {
              "http://example.org/claims": [{"@id": "http://example.org/alice"}]
            }
          }]
        -->
        </pre>
        <pre class="flattened"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-flatten
             data-result-for="Reversing relationship with embedded node-compacted">
        <!--
          [{
            "@id": "http://example.org/alice",
            "http://example.org/claims": [{
              "@id": {
                "@id": "http://example.org/bob",
                "http://example.org/knows": [{"@id": "http://example.org/alice"}]
              }
            }]
          }]
        -->
        </pre>
        <pre class="turtle"
             data-content-type="text/turtle"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-to-rdf
             data-result-for="Reversing relationship with embedded node-compacted">
        <!--
        @prefix : <http://example.org/> .

        :alice :claims << :bob :knows :alice >> .
        -->
        </pre>
      </aside>

      <p>Annotations may themselves use reverse properties, in which case
        the annotated triple will be the subject (instead of the object) of the annotation:</p>

      <aside class="example ds-selector-tabs"
             title="Reversing annotations">
        <div class="selectors">
          <button class="selected input" data-selects="compacted">Compacted (Input)</button>
          <button data-selects="expanded">Expanded</button>
          <button data-selects="flattened">Flattened</button>
          <button data-selects="turtle">Turtle-star</button>
        </div>
        <pre class="compacted input selected"
             data-transform="updateExample"
             data-options="rdfstar=true">
        <!--
          {
            "@context": {
              "@base": "http://example.org/",
              "@vocab": "http://example.org/",
              "accordingTo": {"@type": "@id"},
              "claimedBy": {"@reverse": "http://example.org/claims", "@type": "@id"}
            },
            "@id": "bob",
            "knows": {
              "@id": "alice",
              "@annotation": {
                "accordingTo": "alice",
                "claimedBy": "bob"
              }
            }
          }
        -->
        </pre>
        <pre class="expanded"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-result-for="Reversing annotations-compacted">
        <!--
          [{
            "@id": "http://example.org/bob",
            "http://example.org/knows": [{
              "@id": "http://example.org/alice",
              "@annotation": [{
                "http://example.org/accordingTo": [{"@id": "http://example.org/alice"}],
                "@reverse": {
                  "http://example.org/claims": [{"@id": "http://example.org/bob"}]
                }
              }]
            }]
          }]
        -->
        </pre>
        <pre class="flattened"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-flatten
             data-result-for="Reversing annotations-compacted">
        <!--
          [{
            "@id": "http://example.org/bob",
            "http://example.org/knows": [{"@id": "http://example.org/alice"}],
            "http://example.org/claims": [{
              "@id": {
                "@id": "http://example.org/bob",
                "http://example.org/knows": [{"@id": "http://example.org/alice"}]
              }
            }]
          }, {
          "@id": {
            "@id": "http://example.org/bob",
            "http://example.org/knows": [{"@id": "http://example.org/alice"}]
          },
          "http://example.org/accordingTo": [{"@id": "http://example.org/alice"}]
        }]
        -->
        </pre>
        <pre class="turtle"
             data-content-type="text/turtle"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-to-rdf
             data-result-for="Reversing annotations-compacted">
        <!--
        @prefix : <http://example.org/> .

        :bob :knows :alice .
        << :bob :knows :alice >> :accordingTo :alice .
        :bob :claims << :bob :knows :alice >> .
        -->
        </pre>
      </aside>
    </section>

    <section id="deep-embedding" class="informative">
      <h3>Deep Embedding</h3>

      <p>[[RDFstar]] allows <a>embedded triples</a> to contain other <a>embedded triples</a>, recursively.
        Similarly, an embedded node may be made up of other embedded nodes,
        and annotations may be made upon embedded nodes.</p>

      <aside class="example ds-selector-tabs"
             title="Embedded nodes and annotations">
        <div class="selectors">
          <button class="selected input" data-selects="compacted">Compacted (Input)</button>
          <button data-selects="expanded">Expanded</button>
          <button data-selects="flattened">Flattened</button>
          <button data-selects="turtle">Turtle-star</button>
        </div>
        <pre class="compacted input selected"
             data-transform="updateExample"
             data-options="rdfstar=true">
        <!--
          {
            "@context": {
              "@base": "http://example.org/",
              "@vocab": "http://example.org/",
              "claims": {"@type": "@id"}
            },
            "@id": {
              "@id": "bob",
              "knows": {"@id": "alice"}
            },
            "certainty": {
              "@value": 0.8,
              "@annotation": {"claims": "ted"}
            }
          }
        -->
        </pre>
        <pre class="expanded"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-result-for="Embedded nodes and annotations-compacted">
        <!--
          [{
            "@id": {
              "@id": "http://example.org/bob",
              "http://example.org/knows": [{"@id": "http://example.org/alice"}]
            },
            "http://example.org/certainty": [{
              "@value": 0.8,
              "@annotation": [{
                "http://example.org/claims": [{"@id": "http://example.org/ted"}]
              }]
            }]
          }]
        -->
        </pre>
        <pre class="flattened"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-flatten
             data-result-for="Embedded nodes and annotations-compacted">
        <!--
          [{
            "@id": {
              "@id": "http://example.org/bob",
              "http://example.org/knows": [{"@id": "http://example.org/alice"}]
            },
            "http://example.org/certainty": [{"@value": 0.8}]
          }, {
            "@id": {
              "@id": {
                "@id": "http://example.org/bob",
                "http://example.org/knows": [{"@id": "http://example.org/alice"}]
              },
              "http://example.org/certainty": [{"@value": 0.8}]
            },
            "http://example.org/claims": [{"@id": "http://example.org/ted"}]
          }]
        -->
        </pre>
        <pre class="turtle"
             data-content-type="text/turtle"
             data-transform="updateExample"
             data-options="rdfstar=true,canonicalize=true"
             data-to-rdf
             data-result-for="Embedded nodes and annotations-compacted">
        <!--
        @prefix : <http://example.org/> .

        << :bob :knows :alice >> :certainty 0.8e0 .
        << << :bob :knows :alice >> :certainty 0.8e0 >> :claims :ted .
        -->
        </pre>
      </aside>
    </section>

    <section id="mixing-annotations-and-embedded-nodes" class="informative">
      <h3>Mixing Annotations and Embedded Nodes</h3>
      <p><a>Annotation objects</a> and <a>embedded nodes</a> can be used together.
        As well, <a>annotation objects</a> can be used to annotate <a>embedded nodes</a>
        (see <a href="#deep-embedding" class="sectionRef"></a>),
        <a>embedded nodes</a> may be used within <a>annotation objects</a>,
        and <a>annotation objects</a> may be used to annotate annotations.
        However, the <a href="#grammar-extensions">grammar</a> prevents
        <a>embedded nodes</a> from including <a>annotation objects</a>.</p>

      <p>While it is beyond the scope of this document to discuss use cases
        for these scenarios, it is an important notion of regularity
        of expression, which is shared by formats such as <a data-cite="RDFStar#turtle-star">Turtle-star</a>.</p>

      <p>Consider the following examples:</p>

      <aside class="example ds-selector-tabs"
             title="Annotation containing embedded node">
        <div class="selectors">
          <button class="selected input" data-selects="compacted">Compacted (Input)</button>
          <button data-selects="expanded">Expanded</button>
          <button data-selects="flattened">Flattened</button>
          <button data-selects="turtle">Turtle-star</button>
        </div>
        <pre class="compacted input selected"
             data-transform="updateExample"
             data-options="rdfstar=true">
        <!--
          {
            "@context": {
              "@vocab": "ex:",
              "p1": {"@type": "@id"}
            },
            "@id": "ex:s",
            "p": {
              "@id": "ex:o",
              "@annotation": {
                "r": {
                  "@id": "ex:s1",
                  "@annotation": {
                    "p1": "ex:o1"
                  }
                }
              }
            }
          }
        -->
        </pre>
        <pre class="expanded"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-result-for="Annotation containing embedded node-compacted">
        <!--
          [{
            "@id": "ex:s",
            "ex:p": [{
              "@id": "ex:o",
              "@annotation": [{
                "ex:r": [{
                  "@id": "ex:s1",
                  "@annotation": [{
                    "ex:p1": [{"@id": "ex:o1"}]
                  }]
                }]
              }]
            }]
          }]
        -->
        </pre>
        <pre class="flattened"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-flatten
             data-result-for="Annotation containing embedded node-compacted">
        <!--
          [{
            "@id": "ex:s",
            "ex:p": [{"@id": "ex:o"}]
          }, {
            "@id": {
              "@id": "ex:s",
              "ex:p": [{"@id": "ex:o"}]
            },
            "ex:r": [{"@id": "ex:s1"}]
          }, {
            "@id": {
              "@id": {
                "@id": "ex:s",
                "ex:p": [{"@id": "ex:o"}]
              },
              "ex:r": [{"@id": "ex:s1"}]
            },
            "ex:p1": [{"@id": "ex:o1"}]
          }]
        -->
        </pre>
        <pre class="turtle"
             data-content-type="text/turtle"
             data-transform="updateExample"
             data-options="rdfstar=true,canonicalize=true"
             data-to-rdf
             data-result-for="Annotation containing embedded node-compacted">
        <!--
        @prefix : <ex:> .

        :s :p :o {| :r :s1 {| :p1 :o1 |} |} .
        -->
        </pre>
      </aside>

      <aside class="example ds-selector-tabs"
             title="Annotating an annotation">
        <div class="selectors">
          <button class="selected input" data-selects="compacted">Compacted (Input)</button>
          <button data-selects="expanded">Expanded</button>
          <button data-selects="flattened">Flattened</button>
          <button data-selects="turtle">Turtle-star</button>
        </div>
        <pre class="compacted input selected"
             data-transform="updateExample"
             data-options="rdfstar=true">
        <!--
          {
            "@context": {
              "@vocab": "ex:",
              "p1": {"@type": "@id"}
            },
            "@id": "ex:s",
            "p": {
              "@id": "ex:o",
              "@annotation": {
                "r": {
                  "@id": {"@id": "ex:s1", "p1": "ex:o1"}
                }
              }
            }
          }
        -->
        </pre>
        <pre class="expanded"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-result-for="Annotating an annotation-compacted">
        <!--
          [{
            "@id": "ex:s",
            "ex:p": [{
              "@id": "ex:o",
              "@annotation": [{
                "ex:r": [{
                  "@id": {
                    "@id": "ex:s1",
                    "ex:p1": [{"@id": "ex:o1"}]
                  }
                }]
              }]
            }]
          }]
        -->
        </pre>
        <pre class="flattened"
             data-transform="updateExample"
             data-options="rdfstar=true"
             data-flatten
             data-result-for="Annotating an annotation-compacted">
        <!--
          [{
            "@id": "ex:s",
            "ex:p": [{"@id": "ex:o"}]
          }, {
            "@id": {
              "@id": "ex:s",
              "ex:p": [{"@id": "ex:o"}]
            },
            "ex:r": [{
              "@id": {
                "@id": "ex:s1",
                "ex:p1": [{"@id": "ex:o1"}]
              }
            }]
          }]
          
        -->
        </pre>
        <pre class="turtle"
             data-content-type="text/turtle"
             data-transform="updateExample"
             data-options="rdfstar=true,canonicalize=true"
             data-to-rdf
             data-result-for="Annotating an annotation-compacted">
        <!--
        @prefix : <ex:> .

        :s :p :o {| :r <<:s1 :p1 :o1>> |} .
        -->
        </pre>
      </aside>

      <p>More examples can be found in the [[[JSON-LD-star-tests]]].</p>
    </section>
  </section>

  <section>
    <h2>Data Model</h2>

    <p>The <a data-cite="JSON-LD11#data-model">JSON-LD Data Model</a> is extended consistent with [[RDFStar]]:</p>
    <ul>
      <li>In addition to an <a>IRI</a>, <a>blank node</a>, or <a>literal</a>, a <a>node</a> may itself be an <a>embedded node</a>.</li>
      <li>In addition to an <a>IRI</a> or <a>blank node identifier</a>,
        the `@id` of a <a>node object</a> may be an <a>embedded node</a>.</li>
      <li>The `@id` of an <a>embedded node</a> may also be another <a>embedded node</a>.</li>
      <li>A <a>node object</a> or <a>value object</a> which is the value of some other node object may
        include an <a>annotation object</a>.</li>
    </ul>

    <p><a>Embedded Nodes</a> can be considered as <a data-cite="rdf-primer#reification">reified</a> <a>triples</a>.</p>
    <p class="ednote">Align with [[RDFStar]].</p>
  </section>

  <section id="grammar-extensions">
    <h2>Grammar Extensions</h2>

    <p>The <a data-cite="JSON-LD11#json-ld-grammar"></a> is extended as follows:</p>
    <ul>
      <li>The value of `@id` within a <a>node object</a> MUST be an IRI reference,
        a compact IRI (including <a>blank node identifiers</a>) or an <a>embedded node</a>.</li>
      <li>An <a>embedded node</a> is a <a>node object</a> which MUST describe a single relationship.
        <ul>
          <li>The restrictions on `@id` are identical to those of a <a>node object</a>.</li>
          <li>An <a>embedded node</a> MUST NOT contain any of the following <a>keywords</a> (or alias of such a keywords):
            `@included`, or `@graph`.</li>
          <li>If the <a>embedded node</a> contains `@type` (or an alias), it MUST have a single value
            and the node MUST NOT contain any other non-keyword <a>entries</a>.</li>
          <li>If the <a>embedded node</a> does not contain `@type` (or an alias),
            it MUST have another <a>entry</a> (aside from `@id`) which describes a relationship,
            such as an <a>IRI</a>, `@reverse` having a single value, or `@nest` which ultimately
            resolves to a single property/value relationship.</li>
        </ul>
      </li>
      <li>A <a>node object</a> or a <a>value object</a> MAY contain an `@annotation` property (or an alias) referencing
        zero or more <a>annotation objects</a>.</li>
      <li>A <a>node object</a> which is not the value of a non-keyword property,
        or which is an value of a <a>list object</a>,
        MUST NOT contain an `@annotation` property.</li>
      <li>An <a>annotation object</a> is a <a>node object</a> with the restriction
        that it MUST NOT contain an `@id` (or an alias) <a>entry</a>.</li>
    </ul>
  </section>

  <section>
    <h2>Algorithmic Extensions</h2>

    <p>This specification extends the algorithms from [[[JSON-LD11-API]]] [[JSON-LD11-API]]
      to support the addition of <a>embedded nodes</a> and <a>annotation objects</a>.</p>

    <p>The following algorithm extensions require that the <em>rdfstar</em> flag be set.</p>

    <section>
      <h3>Expansion Algorithm</h3>

      <p>The algorithm has minor updates to allow for an <a>embedded node</a> to be used as the value of `@id`,
        and to allow and validate the special requirements for <a>annotation objects</a>.</p>

      <p class="note">Expansion does not change annotations into <a>embedded nodes</a>,
        neither does it reverse node relationships.
        This is performed by other algorithms.</p>

      <p>Before step 13.4.3.1, and changing 13.4.3.1 to be an "Otherwise, if",
        add the following steps:</p>
      <ol>
        <li>If the <em>rdfstar</em> flag is not set,
          and <var>active property</var> is `@annotation`,
          an <em>invalid annotation</em> error has been detected and processing is aborted.</li>
        <li>If <var>value</var> is a non-empty <a>map</a> and
          the <em>rdfstar</em> flag is set,
          set <var>expanded value</var> to the result of using this algorithm recursively
          passing <var>active context</var>, `null` for <var>active property</var>,
          <var>value</var> for <var>element</var>, <var>base URL</var>,
          and the <em>frameExpansion</em> and <em>ordered</em> flags.
          The resulting expanded value MUST BE a valid <a>embedded node</a>, otherwise,
          an <em>invalid embedded node</em> error has been detected and processing is aborted.</li>
      </ol>

      <p>After step 13.4.14 add the following step:</p>

      <ol>
      <li>If <var>expanded property</var> is `@annotation:
        <ol>
        <li>Continue with the next key from <var>element</var> if the <em>rdfstar</em> flag is not set.</li>
        <li>Set <var>expanded value</var> to the result of using this algorithm recursively
          passing <var>active context</var>, `@annotation` for <var>active property</var>,
          <var>value</var> for element, <var>base URL</var>,
          and the <em>frameExpansion</em> and <em>ordered</em> flags.</li>
        </ol>
      </li>
      </ol>

      <p>Step 15.1 extends the set of allowed <a>entries</a> to include `@annotation`.</p>

      <p>Before <a data-cite="JSON-LD11-API#alg-expand-only-language">step 18</a> add the following step:</p>
      <ol>
      <li>If <var>result</var> contains the <a>entry</a> `@annotation`
        all associated values MUST BE <a>annotation objects</a>, otherwise,
        an <em>invalid annotation</em> error has been detected and processing is aborted.
        Additionally, if there is no <var>active property</var>,
        or <var>active property</var> is `@graph` or `@included`,
        the annotation appears in an inappropriate location and
        an <em>invalid annotation</em> error has been detected and processing is aborted.
      </li>
      </ol>
    </section>

    <section id="compaction-algorithm" class="algorithm">
      <h3>Compaction Algorithm</h3>

      <p>The <a data-cite="JSON-LD11-API#compaction-algorithm">Compaction Algorithm</a> has minor updates to allow for an <a>embedded node</a> to be used as the value of `@id`,
        and to allow <a>embedded nodes</a> and <a>annotation objects</a>.
        Values that might otherwise be serialized as a <a>string</a> must stay
        as a <a>map</a> if they contain an <a>annotation object</a>.</p>

      <p>Step 7 is updated to exclude elements haveing an `@annotation` <a>entry</a>.</p>

      <p>After step 12.1.1, add the following steps:</p>
      <ol>
        <li>Otherwise, if <var>expanded value</var> is an <a>embedded node</a>,
          initialize <var>compacted value</var> with the result of calling
          this algorithm, recursively,
          passing <var>active context</var>,
          `null` for <var>active property</var>,
          <var>expanded value</var> for <var>element</var>,
          and the <a data-cite="JSON-LD11-API#dom-jsonldoptions-compactarrays">compactArrays</a> and <a data-cite="JSON-LD11-API#dom-jsonldoptions-ordered">ordered</a> flags.
        </li>
      </ol>
    </section>

    <section>
      <h3>Flattening Algorithms</h3>

      <p>The flattening algorithms are updated to allow the use
        of <a>embedded nodes</a>, and to turn <a>annotation objects</a>
        into <a>embedded nodes</a>.</p>

      <p>There is a new <a href="#create-annotations">Create Annotations Algorithm</a>
        optionally invoked using the <em>createAnnotations</em> API flag,
        which will re-create most <a>annotation objects</a> within
        a node map.</p>

      <section id="flattening-algorithm" class="algorithm">
        <h4>Flattening Algorithm</h4>
        <p>The main changes to the
          <a data-cite="JSON-LD11-API#flattening-algorithm">Flattening Algorithm</a> is to move the
          <a data-cite="JSON-LD11-API#generate-blank-node-identifier">blank node regeneration</a>
          to a single recursive step run prior to
          running the <a href="#node-map-generation">Node Map Generation</a> algorithm.
          This is required to consistently regenerate <a>blank node identifiers</a>
          used within embedded nodes, which are otherwise untouched
          by the algorithm.</p>

        <p>Before step 2 add the following step:</p>
        <ol>
          <li>Update <var>element</var> using the <a href="#rename-blank-nodes">Rename Blank Nodes</a> algorithm
            passing <var>element</var>.</li>
        </ol>

        <p>Before step 3 add the following step:</p>
        <ol>
          <li>If the <em>createAnnotations</em> flag is set:
            <ol>
              <li>For each key-value pair
                <var>graph name</var>-<var>graph</var> in <var>node map</var>,
                perform the following steps:
                <ol>
                  <li>Update <var>graph</var> in <var>node map</var>
                    by invoking the
                    <a href="#create-annotations">Create Annotations Algorithm</a>
                    passing <var>graph</var> for <var>node map</var>.</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </section>

      <section id="node-map-generation" class="algorithm">
        <h4>Node Map Generation</h4>
        <p><a data-cite="JSON-LD11-API#algorithm-10">Node Map Generation Algorithm</a>
          has significant updates due to the requirements of
          unfolding <a>annotation objects</a> into <a>embedded nodes</a> and representing
          <a>embedded nodes</a> as keys in the <var>node map</var>.
          Also, some assumptions are made in the original algorithm
          that the <var>active subject</var> being a <a>map</a> implies a reverse
          relationship, which is no longer the case when an <a>embedded node</a>
          may be the <var>active subject</var>.</p>

        <p>Principle changes include the following:</p>
        <ul>
          <li>As indicated in <a href="#flattening-algorithm" class="sectionRdf"></a>,
            most <a data-cite="JSON-LD11-API#generate-blank-node-identifier">blank node regeneration</a>
            is performed prior to invoking this algorithm,
            rather than inline.
            The exception is for <a>node objects</a> without an explicit `@id`,
            and where a blank node is used as a property.</li>
          <li>A new argument <var>reverse</var> is introduced which is
            passed when processing an `@reverse` <a>map</a>.</li>
          <li>If an `@annotation` key is encountered, it creates an
            <a>embedded node</a> based on the <var>active subject</var> and
            the map containing the `@annotation` key which is used
            in a recursive invokation of this algorithm on the
            contents of the <var>annotation object</var>.</li>
          <li>If the active subject is an <a>embedded node</a>, the
            result of the [[[RFC8785]]] [[RFC8785]] is used as an
            index into the <var>node map</var>.</li>
        </ul>

        <p>A new optional parameter <var>reverse</var> is added defaulting to `false`.</p>

        <p>In step 2, when referencing the <var>active subject</var> <a>entry</a>
          of <var>graph</var>, if <var>active subject</var> is a <a>map</a>,
          index using the <a data-cite="JSON-LD11-API#dfn-canonical-lexical-form">canonical lexical form</a> of <var>active subject</var>.
          Additionally, do use `null` if <var>reverse</var> is `false`.</p>

        <p>Before step 4.1.1, ad the following steps:</p>
        <ol>
          <li>If <var>element</var> has an `@annotation` entry:
            <ol>
              <li>Initialize <var>annotation subject</var> as a new
                <a>map</a> with an entry for `@id` taken from <var>active subject</var>.
                If <var>active subject</var> is a <a>node reference</a>,
                use value of `@id` from <var>active subject</var>.</li>
              <li>Add an entry for <var>active property</var> with the value
                an <a>array</a> containing <var>element</var>,
                after removing the `@annotation` value from <var>element</var>.</li>
              <li>Initialize <var>annotation</var> as an array containing the values
                from the `@annotation` entry in <var>element</var> adding
                an `@id` entry to each with the value <var>annotation subject</var>.</li>
              <li>Recursively call this algorithm passing <var>annotation</var> for <var>element</var>,
                <var>node map</var>, and <var>active graph</var>.</li>
            </ol>
          </li>
        </ol>

        <p>Replace 6.3 and 6.4 with the following steps:</p>
        <ol>
          <li>If <var>id</var> is a <a>map</a>, set <var>serialized id</var>
            to the <a data-cite="JSON-LD11-API#dfn-canonical-lexical-form">canonical lexical form</a>
            of <var>id</var>, otherwise to <var>id</var>.</li>
          <li>If <var>graph</var> does not contain an <a>entry</a> <var>serialized id</var>,
            create one and initialize its value to a <a>map</a> consisting of
            a single <a>entry</a> <code>@id</code> whose
            value is <var>id</var>.</li>
          <li>Reference the value of the <var>serialized id</var> <a>entry</a> of <var>graph</var> using the
            variable <var>node</var>.</li>
        </ol>

        <p>Change the condition for step 6.5 to check the <var>reverse</var> 
          parameter for `true` rather than if <var>active subject</var> is a <a>map</a>.</p>

        <p>Before step 6.8, ad the following steps:</p>
        <ol>
          <li>If <var>element</var> has an `@annotation` entry:
            <ol>
              <li>Initialize <var>annotation subject</var> as a new
                <a>map</a>.
              <li>If <var>reverse</var> is `true`:
                <ol>
                  <li>Add an entry for `@id` with the value <var>id</var>.</li>
                  <li>Add an entry for <var>active property</var>
                    with the value from <var>active subject</var>.
                    If <var>active subject</var> is a <a>node reference</a>,
                    use value of `@id` from <var>active subject</var>.</li>
                </ol>
              </li>
              <li>Otherwise:
                <ol>
                  <li>Add an entry for `@id` taken from <var>active subject</var>.
                    If <var>active subject</var> is a <a>node reference</a>,
                    use value of `@id` from <var>active subject</var>.</li>
                  <li>Add an entry for <var>active property</var>
                    with the value <var>id</var>.</li>
                </ol>
              </li>
              <li>Initialize <var>annotation</var> as an array containing the values
                from the `@annotation` entry in <var>element</var> adding
                an `@id` entry to each with the value <var>annotation subject</var>.</li>
              <li>Recursively call this algorithm passing <var>annotation</var> for <var>element</var>,
                <var>node map</var>, and <var>active graph</var>.</li>
            </ol>
          </li>
        </ol>

        <p>Update step 6.9.3.1.1 to include a <var>reverse</var>
          parameter with the value `true`.</p>
      </section>

      <section id="rename-blank-nodes" class="algorithm">
        <h4>Rename Blank Nodes</h4>
        <p>This algorithm use used to comprehensively rename the <a>blank node identifiers</a>
          used within a <a>map</a> by recursively visiting each element of the map.</p>
        <p class="note">This will change the naming of renamed blank nodes used
          in existing tests. As indicated in the
          <a href="https://w3c.github.io/json-ld-api/tests/">JSON-LD Test Suite</a>:</p>
        <blockquote>
          When comparing documents after flattening, framing or generating RDF,
          blank node identifiers may not be predictable. 
        </blockquote>
        <p>One way to do this is to transform both the generated results and
          the expected results into an <a>RDF Dataset</a> and perform a blank node
          bijection (as described for <a data-cite="RDF11-CONCEPTS#dfn-dataset-isomorphism">RDF Dataset Isomorphsim</a>) and then
          use the resulting bijection to rename the blank nodes in the result
          based on those that are expected.</p>

          <p>The algorithm takes a single input variable <var>element</var>
            and returns a representation of that <var>element</var>
            with <a>blank node identifiers</a> remapped.</p>

          <ol>
            <li>If <var>element</var> is an <a>array</a>:
              <ol>
                <li>Initialize an empty <a>array</a> <var>result</var>.</li>
                <li>For each <var>item</var> in <var>element</var>
                  add the result of invoking this algorithm recursively
                  passing <var>item</var> for <var>element</var>.
                </li>
              </ol>
            </li>
            <li>Otherwise, if <var>element</var> is a <a>map</a>:
              <ol>
                <li>Initialize an empty <a>map</a> <var>result</var>.</li>
                <li>For each <var>key</var>-<var>value</var> pair in <var>element</var>:
                  <ol>
                    <li>If <var>key</var> is `@id` and <var>value</var> if a <a>blank node identifier</a>,
                      add an <a>entry</a> to <var>result</var> for `@id` with the value from the result of the
                      <a data-cite="JSON-LD11-API#generate-blank-node-identifier">Generate Blank Node Identifier algorithm</a>
                      passing <var>value</var> for <var>identifier</var>.</li>
                    <li>Otherwise, add an <a>entry</a> to <var>result</var> for `@id`
                      with the value from the result of calling this algorithm recursively
                      using <var>value</var> for <var>element</var>.</li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>Otherwise, set <var>result</var> to <var>element</var></li>
          </ol>

          <p>Return <var>result</var>.</p>
      </section>

      <section id="create-annotations" class="algorithm">
        <h4>Create Annotations</h4>

        <p>This algorithm is used to find entries in a <em>node map</em> where
          the key is a canonicalized <a>embedded node</a> and that
          <a>embedded node</a> exists in non-embedded form
          in the <em>node map</em>
          and move them to be <a>annotation objects</a> under that node.
          This effectively reverses the process of unfolding
          <a>annotation objects</a> performed in
          <a href="#node-map-generation" class="sectionRef"></a>.
          It is also used in <a href="#serialize-rdf-as-json-ld" class="sectionRef"></a>.</p>

        <p>The algorithm takes a single input variable <var>node map</var>
          and updates it in place.</p>

        <ol>
          <li>For each <a>entry</a> <var>key</var>/<var>annotation</var> in <var>node map</var>,
            where the first character of <var>key</var>
            is an `OPEN BRACE` (`{`), ordered by decreasing length:
            <ol>
              <li>Initialize <var>embedded</var> from the value
                for the `@id` <a>entry</a> of <var>annotation</var>.</li>
              <li>Initialize <var>id</var> with the value of the `@id`
                entry from <var>embedded</var>, using the
                <a data-cite="JSON-LD11-API#dfn-canonical-lexical-form">canonical lexical form</a>
                if it is a <a>map</a>.</li>
              <li>Initialize <var>node</var> to the entry for <var>id</var>
                in <var>node map</var>. If there is no such <a>entry</a>,
                continue to the next <a>entry</a> in <var>node map</var>.</li>
              <li>Besides `@id`, <var>embedded</var> will have exactly one <a>entry</a>.
                Initialize <var>property</var> and <var>value</var>
                to the key and the first value
                from that <a>entry</a>.</li>
              <li>If <var>node</var> has an entry for <var>property</var>
                with a value <var>value</var>:
                <ol>
                  <li>Remove the <var>key</var> <a>entry</a>
                    from <var>node map</var>.</li>
                  <li>Remove the `@id` <var>entry</var>
                    from <var>annotation</var>.</li>
                  <li>Use <a>add value</a> to add <var>annotation</var> to the property <var>property</var> in <var>node</var>, using `true` for <em>as array</em>.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return <var>node map</var>.</li>
        </ol>
      </section>
    </section>

    <section>
      <h3>RDF Serialization/Deserialization Algorithms</h3>

      <p>The RDF transformation algorithms have minimal changes to allow
        emit and consume <a>RDF-star triples</a>.</p>

      <section id="deserialize-json-ld-to-rdf-algorithm" class="algorithm">
        <h4>Deserialize JSON-LD to RDF Algorithm</h4>

        <p>The <a data-cite="JSON-LD11-API#deserialize-json-ld-to-rdf-algorithm">Deserialize JSON-LD to RDF Algorithm</a>
          has minimal changes to allow
          an <a>embedded triple</a> to be used as the subject or object of
          an <a>RDF-star triple</a>,
          and to use <a>annotation objects</a>, where appropriate.</p>

        <p>After step 1.3.1 add the following step:</p>
        <ol>
          <li>If <var>subject</var> is a <a>string</a> with the
            form of an <a>embedded node</a>. Transform it into an <a>RDF-star triple</a>
            using the <a href="#object-to-rdf-algorithm">Object to RDF Algorithm</a>
            passing <var>subject</var> as <var>item</var>.</li>
        </ol>
      </section>

      <section id="object-to-rdf-algorithm" class="algorithm">
        <h4>Object to RDF Algorithm</h4>

        <p>The <a data-cite="JSON-LD11-API#object-to-rdf">Object to RDF</a> algorithm
          has a minimal update to allow a serialized <a>embedded node</a> to be transformed
          into an <a>RDF-star triple</a> by invoking the
          <a href="#deserialize-json-ld-to-rdf-algorithm">Deserialize JSON-LD to RDF Algorithm</a>
          recursively.</p>

        <p>The first argument MAY be an <a>embedded node</a> in
          <a data-cite="JSON-LD11-API#dfn-canonical-lexical-form">canonical lexical form</a>.</p>

        <p>Before Step 4 add the following steps:</p>
        <ol>
          <li>If <var>item</var> is a <a>string</a> where the first character
            is an `OPEN BRACE` (`{`) it MUST represent a serialized <a>embedded node</a>:
            <ol>
              <li>Initialize <var>dataset</var> as a new empty <a>RDF dataset</a>.</li>
              <li>Transform <var>item</var> into a <a>map</a> by deserializing
                <var>item</var> as JSON.</li>
              <li>Invoke the <a href="#object-to-rdf-algorithm">Object to RDF Algorithm</a>
                passing a new <a>map</a> with the entry `@default` and
                value a new <a>map</a> with a new entry using
                the value of `@id` from <var>entry</var> as key and <var>entry</var>
                as value. If the value of `@id` is not a <a>string</a>,
                use the <a data-cite="JSON-LD11-API#dfn-canonical-lexical-form">canonical lexical form</a>
                as the key.</li>
              <li>The only entry in <var>dataset</var> will be a single
                <a>RDF-star triple</a> in the <a data-cite="JSON-LD11-API#dom-rdfdataset-defaultgraph">defaultGraph</a>.
                Return that <a>RDF-star triple</a>.</li>
            </ol>
          </li>
        </ol>
      </section>

      <section id="serialize-rdf-as-json-ld" class="algorithm">
        <h4>Serialize RDF as JSON-LD Algorithm</h4>

        <p>The <a data-cite="JSON-LD11-API#serialize-rdf-as-json-ld">Serialize RDF as JSON-LD Algorithm</a> algorithm
          has updates to transform <a>RDF-star triples</a> used as
          the subject or object of another triple to be used as the index
          into a <em>node map</em> and represented as <a>embedded nodes</a>.</p>

        <p>Change step 5.7.1 to the following steps:</p>
        <ol>
          <li>If <var>subject</var> is an <a>RDF-star triple</a>:
            <ol>
              <li>Set <var>embedded subject</var> to the
                value of the `@id` entry from the
                result of using
                the <a href="#rdf-to-object-conversion">RDF to Object Conversion algorithm</a>
                passing <var>subject</var>.</li>
              <li>Set <var>subject index</var> to the result of using
                the <a data-cite="JSON-LD11-API#dfn-canonical-lexical-form">canonical lexical form</a>
                of <var>embedded subject</var>.</li>
              <li>If <var>node map</var> does not have a <var>subject index</var> <a>entry</a>,
                create one and initialize its value to a new <a class="changed">map</a>
                consisting of a single <a>entry</a> <code>@id</code> whose value is
                set to <var>embedded subject</var>.</li>
            </ol>
          </li>
          <li>Otherwise, if <var>node map</var> does not have a <var>subject</var> <a>entry</a>,
            create one and initialize its value to a new <a class="changed">map</a>
            consisting of a single <a>entry</a> <code>@id</code> whose value is
            set to <var>subject</var>.</li>
        </ol>

        <p>Before step 5.7.4, add the following steps:</p>
        <ol>
          <li>If <var>object</var> is an <a>RDF-star triple</a>:
            <ol>
              <li>Set <var>embedded object</var> to the
                value of the `@id` entry from the
                result of using
                the <a href="#rdf-to-object-conversion">RDF to Object Conversion algorithm</a>
                passing <var>object</var>.</li>
              <li>Set <var>object index</var> to the result of using
                the <a data-cite="JSON-LD11-API#dfn-canonical-lexical-form">canonical lexical form</a>
                of <var>embedded object</var>.</li>
              <li>If <var>node map</var> does not have an <var>object index</var> <a>entry</a>,
                create one and initialize its value to a new <a class="changed">map</a>
                consisting of a single <a>entry</a> <code>@id</code> whose value is
                set to <var>embedded object</var>.</li>
            </ol>
          </li>
        </ol>

        <p>After step 6.4, add the following steps:</p>
        <ol>
          <li>Update <var>graph object</var> in <var>graph map</var>
            by invoking the
            <a href="#create-annotations">Create Annotations Algorithm</a>
            passing <var>graph object</var> for <var>node map</var>.</li>
        </ol>
      </section>

      <section id="rdf-to-object-conversion" class="algorithm">
        <h4>RDF to Object Conversion</h4>

        <p>The <a data-cite="JSON-LD11-API#rdf-to-object-conversion">RDF to Object Conversion</a> algorithm
          has updates to transform <a>RDF-star triples</a> into an <a>embedded node</a>.</p>

        <p>Before step 2, add the following steps:</p>
        <ol>
          <li>Otherewise, if <var>value</var> is an <a>RDF-star triple</a>:
            <ol>
              <li>Create a new <a>map</a> <var>embedded node</var>
                with the <a>entry</a> `@id` whose value
                is the result of calling this algorithm, recursively,
                passing the <a>subject</a> from <var>value</var>.</li>
              <li>If the <a>predicate</a> from <var>value</var> is `rdf:type`,
                and the <a data-cite="JSON-LD11-API#dom-jsonldoptions-userdftype">useRdfType</a> flag is not `true`,
                add an entry for `@type` whose value
                is an <a>array</a> containing the <a>object</a> from <var>value</var>.</li>
              <li>Otherwise, add an entry for <a>predicate</a> whose value
                is an <a>array</a> containing the result of calling this algorithm,
                recursively,
                passing the <a>object</a> from <var>value</var>.</li>
            </ol>
          </li>
          <li>Return <var>embedded node</var>.</li>
        </ol>
      </section>
    </section>
  </section>
 </body>
</html>
